# План разработки MVP RAG-сервиса в Telegram-боте

## Описание проекта
MVP RAG-сервиса в Telegram-боте для загрузки и анализа документов (PDF, DOCX, TXT) с возможностью общения по содержимому файлов с использованием GPT-4.1 mini через OpenAI API.

## Архитектура решения

### Технический стек:
- **Backend**: FastAPI
- **RAG-фреймворк**: LangChain
- **Векторная БД**: Chroma (локальная, простая в настройке)
- **LLM**: OpenAI GPT-4.1 mini
- **Telegram Bot**: aiogram 3.x
- **Парсинг документов**: PyPDF2, python-docx, обычное чтение для TXT
- **База данных**: SQLite (для метаданных пользователей и истории)
- **Эмбеддинги**: OpenAI text-embedding-ada-002
- **Логирование**: стандартный Python logging

### Структура проекта:
```
RAG/
├── app/
│   ├── __init__.py
│   ├── main.py                 # FastAPI приложение
│   ├── config.py              # Конфигурация
│   ├── database/
│   │   ├── __init__.py
│   │   ├── models.py          # SQLite модели
│   │   └── database.py        # Подключение к БД
│   ├── services/
│   │   ├── __init__.py
│   │   ├── rag_service.py     # RAG логика
│   │   ├── file_parser.py     # Парсинг файлов
│   │   ├── vector_store.py    # Работа с Chroma
│   │   └── openai_service.py  # OpenAI API
│   ├── telegram/
│   │   ├── __init__.py
│   │   ├── bot.py            # Telegram бот
│   │   └── handlers.py       # Обработчики команд
│   └── utils/
│       ├── __init__.py
│       ├── logging_config.py # Настройка логирования
│       └── helpers.py        # Вспомогательные функции
├── data/
│   ├── chroma_db/            # Векторная БД
│   ├── user_files/           # Загруженные файлы
│   └── app.db               # SQLite база
├── logs/                     # Логи
├── requirements.txt
├── .env.example
├── .env
├── README.md
└── run.py                   # Точка входа
```

## Этапы разработки

### Этап 1: Настройка проекта и базовая инфраструктура
**Цель**: Создать основу проекта с конфигурацией и зависимостями

**Шаги**:
1. Создать структуру каталогов
2. Настроить requirements.txt с необходимыми пакетами
3. Создать конфигурационные файлы (.env.example, config.py)
4. Настроить систему логирования
5. Создать базовую модель данных SQLite

**Результат**: Готовая структура проекта с настроенным окружением

### Этап 2: Сервис парсинга файлов
**Цель**: Реализовать модуль для извлечения текста из PDF, DOCX, TXT

**Шаги**:
1. Создать file_parser.py с классами для каждого типа файлов
2. Реализовать методы извлечения текста
3. Добавить обработку ошибок и валидацию файлов
4. Создать унифицированный интерфейс для парсинга

**Результат**: Модуль, способный извлекать текст из поддерживаемых форматов

### Этап 3: Векторная база данных и эмбеддинги
**Цель**: Настроить Chroma для хранения векторных представлений документов

**Шаги**:
1. Создать vector_store.py для работы с Chroma
2. Настроить OpenAI embeddings через API
3. Реализовать методы индексации документов
4. Добавить функции поиска по векторам
5. Обеспечить изоляцию данных между пользователями

**Результат**: Векторное хранилище с возможностью индексации и поиска

### Этап 4: RAG-сервис
**Цель**: Создать основную логику RAG с интеграцией LangChain

**Шаги**:
1. Создать rag_service.py с основными классами RAG
2. Настроить цепочки LangChain для обработки запросов
3. Реализовать контекстный поиск по документам
4. Добавить обработку истории диалога
5. Интегрировать с OpenAI API для генерации ответов

**Результат**: Полнофункциональный RAG-сервис

### Этап 5: FastAPI сервер
**Цель**: Создать REST API для взаимодействия с RAG-сервисом

**Шаги**:
1. Создать main.py с базовым FastAPI приложением
2. Добавить эндпоинты для загрузки файлов
3. Создать эндпоинты для отправки вопросов
4. Реализовать управление пользователями и сессиями
5. Добавить middleware для логирования и обработки ошибок

**Результат**: REST API для взаимодействия с системой

### Этап 6: Telegram бот
**Цель**: Создать интерфейс для пользователей через Telegram

**Шаги**:
1. Создать bot.py с основной логикой бота
2. Реализовать handlers.py для обработки команд и сообщений
3. Добавить обработчики загрузки файлов
4. Создать обработчики текстовых вопросов
5. Интегрировать с FastAPI через внутренние API вызовы

**Результат**: Функциональный Telegram бот

### Этап 7: База данных и управление пользователями
**Цель**: Обеспечить персистентность данных и изоляцию пользователей

**Шаги**:
1. Создать модели SQLite в models.py
2. Реализовать database.py для работы с БД
3. Добавить управление сессиями пользователей
4. Создать систему хранения истории диалогов
5. Обеспечить связь между пользователями и их документами

**Результат**: Надежное хранение данных с изоляцией пользователей

### Этап 8: Интеграция и тестирование
**Цель**: Объединить все компоненты и протестировать систему

**Шаги**:
1. Создать run.py для запуска всех сервисов
2. Протестировать загрузку файлов разных форматов
3. Проверить работу RAG с большими документами
4. Тестировать многопользовательский режим
5. Оптимизировать производительность

**Результат**: Полностью работающий MVP

### Этап 9: Документация и финализация
**Цель**: Подготовить проект к демонстрации

**Шаги**:
1. Создать подробный README.md с инструкциями
2. Добавить примеры использования
3. Оптимизировать код и добавить комментарии
4. Провести финальное тестирование
5. Подготовить демонстрационные материалы

**Результат**: Готовый к демонстрации MVP

## Ключевые особенности реализации

### Изоляция пользователей:
- Каждый пользователь имеет уникальный user_id (Telegram ID)
- Векторные коллекции в Chroma создаются с префиксом user_id
- Файлы сохраняются в папках по user_id
- История диалогов привязана к пользователю

### Обработка больших файлов:
- Разбиение документов на чанки по 1000-1500 символов
- Перекрытие чанков для сохранения контекста
- Батчевая обработка эмбеддингов
- Оптимизированный поиск Top-K релевантных чанков

### Производительность:
- Асинхронная обработка где возможно
- Кеширование часто используемых запросов
- Оптимизированные индексы в SQLite
- Graceful handling больших файлов

### Безопасность:
- Валидация загружаемых файлов
- Ограничения на размер файлов
- Санитизация пользовательского ввода
- Обработка ошибок без раскрытия системной информации

## Примерный workflow пользователя:

1. Пользователь отправляет /start боту
2. Бот приветствует и объясняет возможности
3. Пользователь загружает файл (PDF/DOCX/TXT)
4. Система парсит файл, создает эмбеддинги и сохраняет в векторную БД
5. Пользователь задает вопросы по содержимому
6. Система находит релевантные части документа и генерирует ответ
7. Поддерживается контекст диалога для связанных вопросов

## Время реализации:
Ориентировочно 2-3 дня активной разработки для полного MVP с тестированием. 